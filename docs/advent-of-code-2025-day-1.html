<!doctypehtml><html lang="en"><link rel="icon"type="image/x-icon"href="/favicon.ico"><style>:root{--base-font-size:1rem;--content-max-ch:72ch;--page-gap:1rem}@media (min-width:600px){:root{--base-font-size:1.0625rem}}@media (min-width:900px){:root{--base-font-size:1.125rem}}@media (min-width:1200px){:root{--base-font-size:1.25rem}}@font-face{font-family:"JetBrains Mono";src:url(/assets/fonts/JetBrainsMono-Regular-ascii.woff2) format("woff2");font-weight:400;font-style:normal;font-display:swap;unicode-range:U+0000-00FF}@font-face{font-family:"JetBrains Mono";src:url(/assets/fonts/JetBrainsMono-Regular.woff2) format("woff2");font-weight:400;font-style:normal;font-display:swap;unicode-range:U+0100-024F}@font-face{font-family:'JetBrains Mono';src:url(/assets/fonts/JetBrainsMono-Bold-ascii.woff2) format('woff2');font-weight:700;font-style:normal;font-display:swap;unicode-range:U+0000-00FF}@font-face{font-family:'JetBrains Mono';src:url(/assets/fonts/JetBrainsMono-Bold.woff2) format('woff2');font-weight:700;font-style:normal;font-display:swap;unicode-range:U+0100-024F}@font-face{font-family:'JetBrains Mono';src:url(/assets/fonts/JetBrainsMono-Italic-ascii.woff2) format('woff2');font-weight:400;font-style:italic;font-display:swap;unicode-range:U+0000-00FF}@font-face{font-family:'JetBrains Mono';src:url(/assets/fonts/JetBrainsMono-Italic.woff2) format('woff2');font-weight:400;font-style:italic;font-display:swap;unicode-range:U+0100-024F}html{box-sizing:border-box;background-color:#050506}*,::after,::before{box-sizing:inherit}body{color:#f9f9ff;font-size:var(--base-font-size);font-family:'JetBrains Mono',monospace;line-height:1.5;max-width:var(--content-max-ch);margin:var(--page-gap);margin-inline:auto;padding:0 1rem;overflow-wrap:anywhere;word-break:break-word}a{color:#58a6ff}a:active,a:focus,a:hover{background-color:rgba(36,116,208,.25);border-radius:.25rem}ul{padding:0;margin-left:25px;list-style-type:disc}code{background-color:#222;padding:1px 2px;border-radius:.25rem}pre{background-color:#222;padding:1rem;border-radius:.25rem;overflow:auto;white-space:pre}h1{margin-block-start:0;margin-block-end:var(--base-font-size);text-align:center}p{margin:0 0 calc(var(--base-font-size) * 1.5) 0}img{max-width:72ch}hr{margin:calc(var(--base-font-size) * 2.25) 0}video{max-width:100%;max-height:100%;object-fit:contain}iframe.website{border:0;max-width:200%;display:block;width:var(--content-max-ch);height:100vh}</style><link rel="stylesheet"href="/assets/css/clojure.css"><meta charset="UTF-8"><meta name="description"content="Grahp's PERSONAL website with all his PERSONAL things!"><meta name="viewport"content="width=device-width,initial-scale=1"><title>Advent of Code 2025 Day 1</title><main id="app"><h1>Advent of Code 2025 Day 1</h1><p><a class="wiki-link"href="/advent-of-code-2025">Advent of Code 2025</a> Day 1 :p<p>Yeah I'm late don't worry about it.<p>There are only 12 days anyway right?<p>I'm probably going to spend more time getting code to appear correctly on this page than I am solving the actual puzzle ._.<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="c1">; Test!</span><span class="w">
</span><span class="s">"Foo"</span><span class="w">
</span></code></pre></div></div><p>Did that work?<p>No it did not!<p>Oh I forgot the css :p<p>Okay somehow that broke the styling for the entire page...<p>Yay!<p>Well I already did part 1 and just wrote some comments :p<p>(If you're not familiar with <a class="wiki-link"href="/clojure">Clojure</a>, you should read from bottom up... And also right to left but don't worry about it)<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">dev.grahp.aoc2025.day1</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]))</span><span class="w">

</span><span class="c1">; You have a Dial from 0-99 </span><span class="w">
</span><span class="c1">; Can move Left or Right by 'n'</span><span class="w">
</span><span class="c1">; Dial starts at 50</span><span class="w">
</span><span class="c1">; it wraps around so 99 + 1 = 0, 0 - 1 = 99</span><span class="w">
</span><span class="c1">; Need: The number of times the dial points at zero after doing a rotation</span><span class="w">

</span><span class="c1">; Format: L39 R10 L1903</span><span class="w">
</span><span class="c1">; 11 + R8 = 19</span><span class="w">
</span><span class="c1">; 19 + L8 = 11</span><span class="w">
</span><span class="c1">; 0 + L1 = 99</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">normalize</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
    </span><span class="no">:else</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="no">::keys</span><span class="w"> </span><span class="p">[</span><span class="n">direction</span><span class="w"> </span><span class="n">amount</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nf">normalize</span><span class="w"> </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">direction</span><span class="w">
               </span><span class="no">::left</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">amount</span><span class="p">)</span><span class="w">
               </span><span class="no">::right</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">amount</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse-input-string</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">direction-letter</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">amount</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split-lines</span><span class="w"> </span><span class="n">s</span><span class="p">)]</span><span class="w">
    </span><span class="p">{</span><span class="no">::direction</span><span class="w"> </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">direction-letter</span><span class="w">
                   </span><span class="sc">\L</span><span class="w"> </span><span class="no">::left</span><span class="w">
                   </span><span class="sc">\R</span><span class="w"> </span><span class="no">::right</span><span class="p">)</span><span class="w">
     </span><span class="no">::amount</span><span class="w"> </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">amount</span><span class="p">))}))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">part-1</span><span class="w"> </span><span class="p">[</span><span class="n">input-string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-input-string</span><span class="w"> </span><span class="n">input-string</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">reductions</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="mi">50</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">zero?</span><span class="p">)</span><span class="w">
       </span><span class="nb">count</span><span class="p">))</span><span class="w">
</span></code></pre></div></div><p>This is kinda funky, but it first parses the input string into a "rotation" map with a direction and an amount. Yes this could have just been a number :p<p>But anyways, to rotate the dial, it subtracts to the current count if you're going left and adds if you're going right, and then normalizes the result back to what it's supposed to be with a loop.<p>I looked at someone else's solution (<a href="https://narimiran.github.io/aoc2025/src/day01/"class="web-link">https://narimiran.github.io/aoc2025/src/day01/</a>) and learned that modulo does this :p<p>So because I can't help myself I'm just going to...<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">dev.grahp.aoc2025.day1</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">amount</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">amount</span><span class="p">)</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse-input-string</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[[</span><span class="n">direction-letter</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">amount</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split-lines</span><span class="w"> </span><span class="n">s</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">amount</span><span class="p">))]</span><span class="w">
      </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">direction-letter</span><span class="w">
        </span><span class="sc">\L</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
        </span><span class="sc">\R</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">part-1</span><span class="w"> </span><span class="p">[</span><span class="n">input-string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-input-string</span><span class="w"> </span><span class="n">input-string</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">reductions</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="mi">50</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">zero?</span><span class="p">)</span><span class="w">
       </span><span class="nb">count</span><span class="p">))</span><span class="w">
</span></code></pre></div></div><p>I used <code class="language-plaintext highlighter-rouge">case</code> instead of <code class="language-plaintext highlighter-rouge">if</code> because I think it'd be better to fail on a bad input right?<p>Anyways, <code class="language-plaintext highlighter-rouge">reductions</code> is pretty cool here. <code class="language-plaintext highlighter-rouge">reductions</code> returns a list of each step of calling <code class="language-plaintext highlighter-rouge">rotate</code> with the current dial position and the next amount to rotate from the input.<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="s">"L68
L30
R48
L5
R60
L55
L1
L99
R14
L82"</span><span class="w">
     </span><span class="c1">;; Each of the parsed inputs</span><span class="w">
     </span><span class="n">parse-input-string</span><span class="w"> </span><span class="o">#</span><span class="n">_</span><span class="p">(</span><span class="nf">-68</span><span class="w"> </span><span class="mi">-30</span><span class="w"> </span><span class="mi">48</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="mi">-55</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">-99</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">-82</span><span class="p">)</span><span class="w">
		 </span><span class="c1">;; What they are after rotating with the current position of the dial</span><span class="w">
     </span><span class="p">(</span><span class="nf">reductions</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="mi">50</span><span class="p">))</span><span class="w"> </span><span class="o">#</span><span class="n">_</span><span class="p">(</span><span class="nf">50</span><span class="w"> </span><span class="mi">82</span><span class="w"> </span><span class="mi">52</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">95</span><span class="w"> </span><span class="mi">55</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w">
</span></code></pre></div></div><p>Then <code class="language-plaintext highlighter-rouge">(count (filter zero?))</code> to get the number of times the dial was at zero!</main><script type="module"src="/assets/js/app.js"></script>