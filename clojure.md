# Clojure

I couldn't do Clojure justice. ([https://clojure.org](https://clojure.org))

## Data

Clojure forces you to write data-driven systems. Data is incredibly simple.

Process is HARD. When using process over data, you have to understand every single step that got you to where you are now. When working with data, you have a clear trustworthy source of truth.

Data is obvious. Data is transparent. You can look at data and see with your eyes what went wrong. That data is never going to change. If your data works, it will continue to work for the rest of eternity. If your process works, you're always only one step away from your process breaking. That's broken.

You can qualify data. It's transparent, just run predicates against it. You can't qualify process. To qualify process, you must first catch lightning in a bottle. After you've caught lightning in a bottle, you can validate your process. Then, the very instant you validate your process, your process is now invalid. By invalid, I mean potentially invalid, which is the same thing.

Information is data, systems are process. You should be actively trying to avoid process as much as you possibly can.

Continuous data processes can be datafied. A datafied process is no longer a process, it is now data. The world moves on, but you don't have to.

Clojure forces you to write datafiable process.

Even clojure code is data! You can write programs that write programs in your programs. If that sounds confusing that's because it is. Don't do that. Let somebody else do it.

Check out my [projects](projects.md).
