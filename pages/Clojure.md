---
permalink: clojure
title: Clojure
---
I couldn't do Clojure justice. ([https://clojure.org](https://clojure.org))

## Data

Clojure forces you to write data-driven systems. Data is incredibly simple.

Process is HARD. When using process over data, you have to understand every single step that got you to where you are now. When working with data, you have a clear trustworthy source of truth.

Data is obvious. Data is transparent. You can look at data and see with your eyes what went wrong. That data is never going to change. If your data works, it will continue to work for the rest of eternity. If your process works, you're always only one step away from your process breaking. That's broken.

You can qualify data. It's transparent, just look at it. You cannot qualify process. To qualify process, you must first catch lightning in a bottle. Great, now you can qualify your process. Except the very instant you qualify your process, it is now invalid, since it could've changed.

Information is data, systems are process. You should be actively trying to avoid process as much as you possibly can.

Continuous data processes can be datafied. A datafied process is no longer a process, it is now data. The world moves on, but you don't have to.

Clojure forces you to write datafiable process.

Even Clojure code is data! You edit code in the same way you edit data. Since code is data, you can assign arbitrary meaning to that data. Creating new language syntax!

Check out my [[Projects]].
